# 구현(Implementation)

머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정

모든 범위의 코딩 테스트 문제 유형을 포함하는 개념

- 완전 탐색: 모든 경우의 수를 계산
- 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

## 구현 시 고려해야 할 메모리 제약 사항

### 변수 표현 범위

**C/C++/Java**

- int(정수형): 4바이트
- long long(더 큰 정수형): 8바이트

**Python**

직접 자료형을 지정하지 않아도 됨

(주의) 실수형 변수: 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있음

### 리스트 크기 제약

- 대체적으로 128~512MB로 메모리를 제한하므로, 데이터 처리량이 많을 때 메모리 제한을 고려해야 함
- 단, 일반적인 코딩 테스트 수준에서는 메모리 사용량 제한보다 더 적은 크기의 메모리를 사용

<int 자료형 데이터의 개수에 따른 메모리 사용량>

| 데이터 개수(리스트의 길이) | 메모리 사용량 |
| -------------------------- | ------------- |
| 1,000                      | 약 4KB        |
| 1,000,000                  | 약 4MB        |
| 10,000,000                 | 약 40MB       |

## 채점 환경

1초에 2,000만 번의 연산을 수행한다고 가정

시간 제한이 1초, 데이터의 개수가 100만 개 ⇒ 시간 복잡도 $O(NlogN)$ 이내의 알고리즘을 이용

### 예제 1 - 상하좌우

- **문제**: N*N 크기의 정사각형 공간에서 계획대로 움직였을 때 최종적으로 도착할 지점의 좌표는?
    - 좌표 (x,y): (1,1)부터 (N,N)까지
    - 시작 좌표는 항상 (1,1)
    - 방향: L(좌), R(우), U(상), D(하)
    - 정사각형 공간을 벗어나는 움직임은 무시됨
- **풀이**: 시뮬레이션 유형 → L, R, U, D에 따른 이동 방향을 미리 설정
- **비고**: 연산 횟수는 이동 횟수에 비례 ⇒ 시간 복잡도 $O(N)$

```python
n = int(input())
x, y = 1, 1  # 초기 좌표
plans = input().split()  # 이동 계획

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]  # x좌표
dy = [-1, 1, 0, 0]  # y좌표
move_types = ['L', 'R', 'U', 'D']

# 이동 계획을 하나씩 확인
for plan in plans:
  # 이동 후 좌표 구하기
  for i in range(len(move_types)):
    if plan == move_types[i]:
      nx = x + dx[i]
      ny = y + dy[i]
  # 공간 벗어나면 무시
  if nx < 1 or ny < 1 or nx > n or ny > n:
    continue
  # 이동 수행
  x, y = nx, ny

print(x, y)
```

### 예제 2 - 시각

- **문제**: 00시 00분 00초부터 N시 59분 59초까지 모든 시각 중, 3이 하나라도 포함되는 모든 경우의 수
- **풀이**: 시각을 1씩 증가시키며 3 포함 여부 확인 - 3중 반복문
    - 예) 03시 20분 24초 = ‘032024’ ⇒ 3 포함 여부 확인
    - **완전 탐색(Brute Forcing)**: 가능한 모든 경우의 수를 탐색하는 방법, 데이터 개수가 작을 때 적합(100만 개 이하)
- **비고**: 하루는 86,400초이므로 제한 시간 2초 안에 문제 해결 가능

```python
n = int(input())
count = 0

for i in range(n+1): # 0부터 n까지
  for j in range(60):
    for k in range(60):
      if '3' in str(i) + str(j) + str(k): # 3이 포함되면 카운트
        count += 1

print(count)
```

### 실전 1 - 왕실의 나이트

- **문제**: 8*8 좌표 평면에서 나이트가 이동할 수 있는 경우의 수
    - 나이트가 이동할 수 있는 경우 (단, 평면 밖으로 나갈 수 없음)
        1. 수평 2칸 → 수직 1칸
        2. 수직 2칸 → 수평 1칸
    - 행 위치: 1~8 / 열 위치: a~h
    - 예) 현위치 = a1일 때, c2, b3으로 이동 가능 → 2가지
- **풀이**:
    - 이동할 수 있는 모든 경로를 `step` 변수에 넣음 [(-2,-1), (-1,-2), (1,-2), …]
    - `반복문`: 현재 위치에서 이동 경로를 더한 후 좌표 평면 위에 있는지 확인
- **비고**: 예제 4-1 ‘상하좌우’ 문제처럼 dx, dy를 활용할 수도 있고, 이번 문제처럼 변수 안에 넣을 수도 있음, 2가지 형태 모두 자주 사용됨

```python
knight = input() # 나이트의 현위치
row = int(knight[1]) # 행
column = int(ord(knight[0])) - int(ord('a')) + 1 # 열
result = 0 # 경우의 수

# 나이트가 이동할 수 있는 8가지 방향
steps = [(1,2), (1,-2), (-1,2), (-1,-2), (2,1), (2,-1), (-2,1), (-2,-1)]

# 8가지 방향에 대하여 이동 가능한지 확인
for step in steps:
  # 이동하고자 하는 위치 확인
  next_row = row + step[0]
  next_column = column + step[1]
  # 이동 가능하면 카운트 증가
  if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
    result += 1

result(result)
```

### 실전 2 - 게임 개발

- **문제**: 매뉴얼에 따라 캐릭터를 이동시키며 방문한 칸의 수를 출력하라
    - 1*1 정사각형으로 이루어진 n*m 직사각형(3≤n, m≤50): 각각의 칸은 육지(0) or 바다(1)
    - 캐릭터는 북(0), 동(1), 남(2), 서(3) 중 한 곳을 바라봄
    - 캐릭터는 상하좌우로 이동 가능, 바다에는 갈 수 없음
    - 매뉴얼
        1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 90도 회전)부터 차례대로 갈 곳 결정
        2. 아직 가보지 않은 칸이 존재 → 왼쪽 방향으로 회전하여 왼쪽으로 1칸 전진 / 가보지 않은 칸이 없음 → 왼쪽 방향으로 회전만 하고 1단계로 돌아감
        3. 네 방향 모두 가봤거나 바다로 되어있음 → 바라보는 방향 유지하며 1칸 후진하고 1단계로 돌아감 / 후진할 수 없을 경우 움직임을 멈춤
- **풀이**:
    - 예제 4-1 ‘상하좌우’ 문제처럼 dx, dy를 활용
    - 리스트 컴프리헨션을 이용하여 2차원 리스트 초기화
    - 반복문 활용

```python
n, m = map(int, input().split()) # 맵의 행과 열 수
d = [[0]*m for _ in range(n)] # 맵 초기화
x, y, direction = map(int, input().split()) # 현재 위치, 방향
d[x][y] = 1 # 현재 좌표 방문 처리

# 전체 맵 정보
array = []
for i in range(n):
  array.append(list(map(int, input().split())))

# 북, 동, 남, 서에 따른 이동 방향
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 왼쪽으로 회전
def turn_left():
  global direction # 전역변수
  direction -= 1
  if direction == -1:
    direction = 3

count = 1 # 방문한 칸의 수
turn_time = 0 # 회전한 횟수
while True:
  turn_left()
  nx = x + dx[direction]
  ny = y + dy[direction]
  # 정면에 가보지 않은 칸이 존재하고 육지이면 전진
  if d[nx][ny] == 0 and array[nx][ny] == 0:
    d[nx][ny] = 1
    x = nx
    y = ny
    count += 1
    turn_time = 0
    coutinue
  else:
    turn_time += 1
  # 네 방향 모두 갈 수 없는 경우
  if turn_time == 4:
    # 육지면 1칸 후진, 바다면 반복문 종료
    nx = x - dx[direction]
    nx = y - dy[direction]
    if array[nx][ny] == 0:
      x = nx
      y = ny
    else:
      break
    turn_time = 0

print(count)
```